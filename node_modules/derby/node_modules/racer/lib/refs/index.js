// Generated by CoffeeScript 1.3.1
var createRef, createRefList, derefPath, diffArrays, equal, exports, isPrivate, isServer, mixin, racer, regExpPathOrParent, regExpPathsOrChildren, _ref, _ref1,
  __slice = [].slice;

_ref = require('../path'), isPrivate = _ref.isPrivate, regExpPathOrParent = _ref.regExpPathOrParent, regExpPathsOrChildren = _ref.regExpPathsOrChildren;

derefPath = require('./util').derefPath;

createRef = require('./ref');

createRefList = require('./refList');

diffArrays = require('../diffMatchPatch').diffArrays;

_ref1 = require('../util'), isServer = _ref1.isServer, equal = _ref1.equal;

racer = require('../racer');

exports = module.exports = function(racer) {
  return racer.mixin(mixin);
};

exports.useWith = {
  server: true,
  browser: true
};

mixin = {
  type: 'Model',
  server: __dirname + '/refs.server',
  events: {
    init: function(model) {
      var Model, memory, method, _fn;
      model._root = model;
      model._refsToBundle = [];
      model._fnsToBundle = [];
      Model = model.constructor;
      _fn = function(method) {
        return model.on(method, function(_arg) {
          var path;
          path = _arg[0];
          return model.emit('mutator', method, path, arguments);
        });
      };
      for (method in Model.mutator) {
        _fn(method);
      }
      memory = model._memory;
      return model.on('beforeTxn', function(method, args) {
        var data, fn, obj, path;
        if (path = args[0]) {
          data = model._specModel();
          obj = memory.get(path, data);
          if (fn = data.$deref) {
            args[0] = fn(method, args, model, obj);
          }
        }
      });
    },
    bundle: function(model) {
      var from, get, item, onLoad, _i, _j, _len, _len1, _ref2, _ref3, _ref4;
      onLoad = model._onLoad;
      _ref2 = model._refsToBundle;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        _ref3 = _ref2[_i], from = _ref3[0], get = _ref3[1], item = _ref3[2];
        if (model._getRef(from) === get) {
          onLoad.push(item);
        }
      }
      _ref4 = model._fnsToBundle;
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        item = _ref4[_j];
        if (item) {
          onLoad.push(item);
        }
      }
    }
  },
  proto: {
    _getRef: function(path) {
      return this._memory.get(path, this._specModel(), true);
    },
    _ensurePrivateRefPath: function(from, modelMethod) {
      if (!isPrivate(this.dereference(from, true))) {
        throw new Error("Cannot create " + modelMethod + " on public path '" + from + "'");
      }
    },
    dereference: function(path, getRef) {
      var data;
      if (getRef == null) {
        getRef = false;
      }
      this._memory.get(path, data = this._specModel(), getRef);
      return derefPath(data, path);
    },
    ref: function(from, to, key, hardLink) {
      return this._createRef(createRef, 'ref', from, to, key, hardLink);
    },
    refList: function(from, to, key, hardLink) {
      return this._createRef(createRefList, 'refList', from, to, key, hardLink);
    },
    _createRef: function(refFactory, modelMethod, from, to, key, hardLink) {
      var get, listener, model, previous, value;
      if (this._at) {
        hardLink = key;
        key = to;
        to = from;
        from = this._at;
      } else if (from._at) {
        from = from._at;
      }
      if (to._at) {
        to = to._at;
      }
      if (key && key._at) {
        key = key._at;
      }
      model = this._root;
      model._ensurePrivateRefPath(from, modelMethod);
      get = refFactory(model, from, to, key, hardLink);
      listener = model.on('beforeTxn', function(method, args) {
        if (method === 'set' && args[1] === get) {
          args.cancelEmit = true;
          model.removeListener('beforeTxn', listener);
        }
      });
      previous = model.set(from, get);
      value = model.get(from);
      model.emit('set', [from, value], previous, true, void 0);
      if (typeof this._onCreateRef === "function") {
        this._onCreateRef(modelMethod, from, to, key, get);
      }
      return model.at(from);
    },
    fn: function() {
      var fn, fullPath, i, input, inputs, model, path, _i, _j, _len;
      inputs = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), fn = arguments[_i++];
      for (i = _j = 0, _len = inputs.length; _j < _len; i = ++_j) {
        input = inputs[i];
        if (fullPath = input._at) {
          inputs[i] = fullPath;
        }
      }
      if (this._at) {
        path = this._at + '.' + inputs.shift();
      } else {
        path = inputs.shift();
      }
      model = this._root;
      model._ensurePrivateRefPath(path, 'fn');
      if (typeof fn === 'string') {
        fn = new Function('return ' + fn)();
      }
      return model._createFn(path, inputs, fn);
    },
    _createFn: function(path, inputs, fn, destroy, prevVal, currVal) {
      var listener, model, reInput, reSelf, updateVal,
        _this = this;
      reSelf = regExpPathOrParent(path);
      reInput = regExpPathsOrChildren(inputs);
      destroy = typeof this._onCreateFn === "function" ? this._onCreateFn(path, inputs, fn) : void 0;
      listener = this.on('mutator', function(mutator, mutatorPath, _arguments) {
        if (_arguments[3] === listener) {
          return;
        }
        if (reSelf.test(mutatorPath) && !equal(_this.get(path), currVal)) {
          _this.removeListener('mutator', listener);
          return typeof destroy === "function" ? destroy() : void 0;
        }
        if (reInput.test(mutatorPath)) {
          return currVal = updateVal();
        }
      });
      model = this.pass(listener);
      return (updateVal = function() {
        var input;
        prevVal = currVal;
        currVal = fn.apply(null, (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = inputs.length; _i < _len; _i++) {
            input = inputs[_i];
            _results.push(this.get(input));
          }
          return _results;
        }).call(_this));
        if (equal(prevVal, currVal)) {
          return currVal;
        }
        model.set(path, currVal);
        return currVal;
      })();
    }
  }
};
