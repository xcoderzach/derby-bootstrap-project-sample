// Generated by CoffeeScript 1.3.1
var LiveQuery, Memory, applyTxn, deepCopy, deserializeQuery, finishAfter, isServer, memory, publish, queryInterface, transaction, _ref,
  __slice = [].slice;

_ref = require('../../util'), isServer = _ref.isServer, deepCopy = _ref.deepCopy, finishAfter = _ref.finishAfter;

console.assert(isServer);

Memory = require('../../Memory');

transaction = require('../../transaction.server');

LiveQuery = require('../../pubSub/LiveQuery');

deserializeQuery = require('../../pubSub/Query').deserialize;

module.exports = queryInterface = function(pubSub, store) {
  var intf, liveQueries, reverseIndex;
  reverseIndex = {};
  liveQueries = store._liveQueries;
  intf = {};
  intf.subscribe = function(subscriberId, query, ackCb) {
    var hash, hashes;
    hash = query.hash();
    hashes = reverseIndex[subscriberId] || (reverseIndex[subscriberId] = {});
    hashes[hash] = true;
    liveQueries[hash] || (liveQueries[hash] = new LiveQuery(query));
    return pubSub.string.subscribe(subscriberId, ["$q." + hash], ackCb);
  };
  intf.publish = function(_arg, meta) {
    var newDoc, origDoc, params, txn, type;
    type = _arg.type, params = _arg.params;
    if (!(type === 'txn' && meta)) {
      return;
    }
    txn = params.data;
    if (!(origDoc = meta.origDoc)) {
      return publish(store, params, meta);
    }
    newDoc = origDoc ? deepCopy(origDoc) : transaction.getArgs(txn)[1];
    newDoc = applyTxn(txn, newDoc);
    return publish(store, params, origDoc, newDoc);
  };
  intf.unsubscribe = function(subscriberId, query, ackCb) {
    var channels, hash, hashes;
    if (!(query != null ? query.isQuery : void 0)) {
      hashes = reverseIndex[subscriberId];
      delete reverseIndex[subscriberId];
      channels = (function() {
        var _results;
        _results = [];
        for (hash in hashes) {
          _results.push("$q." + hash);
        }
        return _results;
      })();
      if (ackCb = query) {
        ackCb = finishAfter(channels.length, ackCb);
      }
    } else {
      channels = ["$q." + (query.hash())];
    }
    if (!channels.length) {
      return typeof ackCb === "function" ? ackCb(null) : void 0;
    }
    return pubSub.unsubscribe(subscriberId, channels, ackCb);
  };
  intf.hasSubscriptions = function(subscriberId) {
    return subscriberId in reverseIndex;
  };
  intf.subscribedTo = function(subscriberId, query) {
    return pubSub.subscribedTo(subscriberId, "$q." + (query.hash()));
  };
  return intf;
};

publish = function(store, params, origDoc, newDoc) {
  var channel, doc, hash, liveQueries, nsPlusId, parts, pseudoVer, pubSub, query, txn, txnId, txnNs, txnPath, txnVer, _ref1;
  txn = params.data;
  txnVer = transaction.getVer(txn);
  pseudoVer = function() {
    return txnVer += 0.01;
  };
  txnPath = transaction.getPath(txn);
  _ref1 = parts = txnPath.split('.'), txnNs = _ref1[0], txnId = _ref1[1];
  nsPlusId = txnNs + '.' + txnId;
  liveQueries = store._liveQueries, pubSub = store._pubSub;
  if (transaction.getMethod(txn) === 'set' && parts.length === 2) {
    doc = transaction.getArgs(txn)[1];
    for (hash in liveQueries) {
      query = liveQueries[hash];
      channel = "$q." + hash;
      if (query.isPaginated) {
        if (!query.testWithoutPaging(doc, nsPlusId)) {
          continue;
        }
        query.updateCache(store, function(err, newMembers, oldMembers, ver) {
          var mem, _i, _j, _len, _len1, _results;
          if (err) {
            throw err;
          }
          for (_i = 0, _len = newMembers.length; _i < _len; _i++) {
            mem = newMembers[_i];
            pubSub.publish({
              type: 'addDoc',
              params: {
                channel: channel,
                data: {
                  ns: txnNs,
                  doc: mem,
                  ver: pseudoVer()
                }
              }
            });
          }
          _results = [];
          for (_j = 0, _len1 = oldMembers.length; _j < _len1; _j++) {
            mem = oldMembers[_j];
            _results.push(pubSub.publish({
              type: 'rmDoc',
              params: {
                channel: channel,
                data: {
                  ns: txnNs,
                  doc: mem,
                  hash: hash,
                  id: mem.id,
                  ver: pseudoVer()
                }
              }
            }));
          }
          return _results;
        });
      }
      if (!query.test(doc, nsPlusId)) {
        continue;
      }
      if (!query.isPaginated || (query.isPaginated && query.isCacheImpactedByTxn(txn))) {
        pubSub.publish(channel, params);
        pubSub.publish({
          type: 'txn',
          params: {
            channel: channel,
            data: txn
          }
        });
      }
    }
    return;
  }
  for (hash in liveQueries) {
    query = liveQueries[hash];
    channel = "$q." + hash;
    if (query.isPaginated) {
      if (query.testWithoutPaging(origDoc, nsPlusId) || query.testWithoutPaging(newDoc, nsPlusId)) {
        query.updateCache(store, function(err, newMembers, oldMembers, ver) {
          var mem, _i, _j, _len, _len1;
          if (err) {
            throw err;
          }
          for (_i = 0, _len = newMembers.length; _i < _len; _i++) {
            mem = newMembers[_i];
            pubSub.publish({
              type: 'addDoc',
              params: {
                channel: channel,
                data: {
                  ns: txnNs,
                  doc: mem,
                  ver: pseudoVer()
                }
              }
            });
          }
          for (_j = 0, _len1 = oldMembers.length; _j < _len1; _j++) {
            mem = oldMembers[_j];
            pubSub.publish({
              type: 'rmDoc',
              params: {
                channel: channel,
                data: {
                  ns: txnNs,
                  doc: mem,
                  hash: hash,
                  id: mem.id,
                  ver: pseudoVer()
                }
              }
            });
          }
          if (query.isCacheImpactedByTxn(txn)) {
            pubSub.publish({
              type: 'txn',
              params: {
                channel: channel,
                data: txn
              }
            });
          }
        });
      }
    } else if (query.test(origDoc, nsPlusId)) {
      if (query.test(newDoc, nsPlusId)) {
        pubSub.publish({
          type: 'txn',
          params: {
            channel: channel,
            data: txn
          }
        });
      } else {
        pubSub.publish({
          type: 'rmDoc',
          params: {
            channel: channel,
            data: {
              ns: txnNs,
              doc: newDoc,
              hash: hash,
              id: origDoc.id,
              ver: pseudoVer()
            }
          }
        });
      }
    } else if (query.test(newDoc, nsPlusId)) {
      pubSub.publish({
        type: 'addDoc',
        params: {
          channel: channel,
          data: {
            ns: txnNs,
            doc: newDoc,
            ver: pseudoVer()
          }
        }
      });
      pubSub.publish({
        type: 'txn',
        params: {
          channel: channel,
          data: txn
        }
      });
    }
  }
};

memory = new Memory;

memory.setVersion = function() {};

applyTxn = function(txn, doc) {
  var args, data, id, method, ns, path, world, _ref1;
  method = transaction.getMethod(txn);
  args = transaction.getArgs(txn);
  path = transaction.getPath(txn);
  if (method === 'del' && path.split('.').length === 2) {
    return;
  }
  _ref1 = path.split('.'), ns = _ref1[0], id = _ref1[1];
  world = {};
  world[ns] = {};
  world[ns][id] = doc;
  data = {
    world: world
  };
  try {
    memory[method].apply(memory, __slice.call(args).concat([-1], [data]));
  } catch (err) {

  }
  return doc;
};
