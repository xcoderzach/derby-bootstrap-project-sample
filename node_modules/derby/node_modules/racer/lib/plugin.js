// Generated by CoffeeScript 1.3.1
var isServer, mergeAll, mergeProto, plugable, _ref, _require,
  __slice = [].slice;

_ref = require('./util'), mergeAll = _ref.mergeAll, isServer = _ref.isServer;

_require = require;

plugable = {};

module.exports = {
  _makePlugable: function(name, object) {
    return plugable[name] = object;
  },
  use: function(plugin, options) {
    var decorate, target;
    if (typeof plugin === 'string') {
      if (!isServer) {
        return this;
      }
      plugin = _require(plugin);
    }
    decorate = plugin.decorate;
    target = decorate == null || decorate === 'racer' ? this : plugable[decorate];
    if (!target) {
      throw new Error('invalid plugin.decorate value: ' + decorate);
    }
    target._plugins || (target._plugins = []);
    if (-1 === target._plugins.indexOf(plugin)) {
      target._plugins.push(plugin);
      plugin(target, options);
    }
    return this;
  },
  mixin: function() {
    var Klass, fn, mixin, name, server, type, _i, _len, _ref1,
      _this = this;
    for (_i = 0, _len = arguments.length; _i < _len; _i++) {
      mixin = arguments[_i];
      if (typeof mixin === 'string') {
        if (!isServer) {
          continue;
        }
        mixin = _require(mixin);
      }
      if (!(type = mixin.type)) {
        throw new Error("Mixins require a type parameter");
      }
      if (!(Klass = this["protected"][type])) {
        throw new Error("Cannot find racer.protected." + type);
      }
      if (Klass.mixins) {
        Klass.mixins.push(mixin);
      } else {
        Klass.mixins = [mixin];
        Klass.prototype.mixinEmit = function() {
          var args, name;
          name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return _this.emit.apply(_this, [type + ':' + name].concat(__slice.call(args)));
        };
      }
      mergeAll(Klass, mixin["static"]);
      mergeProto(mixin.proto, Klass);
      if (isServer && (server = mixin.server)) {
        server = typeof server === 'string' ? _require(server) : mixin.server;
        mergeProto(server, Klass);
      }
      _ref1 = mixin.events;
      for (name in _ref1) {
        fn = _ref1[name];
        this.on(type + ':' + name, fn);
      }
      this.emit(type + ':mixin', Klass);
    }
    return this;
  }
};

mergeProto = function(protoSpec, Klass) {
  var descriptor, fn, groupName, key, methods, name, targetPrototype, value, _i, _len, _ref1;
  targetPrototype = Klass.prototype;
  for (name in protoSpec) {
    descriptor = protoSpec[name];
    if (typeof descriptor === 'function') {
      targetPrototype[name] = descriptor;
      continue;
    }
    fn = targetPrototype[name] = descriptor.fn;
    for (key in descriptor) {
      value = descriptor[key];
      switch (key) {
        case 'fn':
          continue;
        case 'type':
          _ref1 = value.split(',');
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            groupName = _ref1[_i];
            methods = Klass[groupName] || (Klass[groupName] = {});
            methods[name] = fn;
          }
          break;
        default:
          fn[key] = value;
      }
    }
  }
};
