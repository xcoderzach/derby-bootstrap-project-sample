// Generated by CoffeeScript 1.3.1
var EventEmitter, PubSub, finishAfter, isPattern;

EventEmitter = require('events').EventEmitter;

finishAfter = require('../util/async').finishAfter;

isPattern = function(x) {
  return -1 !== x.indexOf('*');
};

module.exports = PubSub = function() {
  EventEmitter.call(this);
  this._channelTypes = {
    pattern: function(x) {
      return typeof x === 'string' && isPattern(x);
    },
    prefix: function(x) {
      return typeof x === 'string';
    },
    string: function(x) {
      return typeof x === 'string';
    },
    query: function(x) {
      return x.isQuery;
    }
  };
  this.string = Object.create(this, {
    _channelTypes: {
      value: {
        string: this._channelTypes.string
      }
    }
  });
  this.prefix = Object.create(this, {
    _channelTypes: {
      value: {
        prefix: this._channelTypes.prefix
      }
    }
  });
  this.pattern = Object.create(this, {
    _channelTypes: {
      value: {
        pattern: this._channelTypes.pattern
      }
    }
  });
  this.query = Object.create(this, {
    _channelTypes: {
      value: {
        query: this._channelTypes.query
      }
    }
  });
};

PubSub.prototype = {
  __proto__: EventEmitter.prototype,
  subscribe: function(subscriberId, channels, callback) {
    var channel, numChannels, type, _i, _len;
    numChannels = channels.length;
    if (numChannels > 1) {
      callback = finishAfter(numChannels, callback);
    }
    for (_i = 0, _len = channels.length; _i < _len; _i++) {
      channel = channels[_i];
      if (!(type = this._channelType(channel))) {
        throw new Error("Channel " + channel + " doesn't match a channel type");
      }
      type.subscribe(subscriberId, channel, callback);
    }
    return this;
  },
  publish: function(message, meta) {
    var type, _, _ref;
    _ref = this._channelTypes;
    for (_ in _ref) {
      type = _ref[_];
      type.publish(message, meta);
    }
  },
  unsubscribe: function(subscriberId, channels, callback) {
    var channel, numChannels, type, _, _i, _len, _ref;
    if (!(numChannels = channels != null ? channels.length : void 0)) {
      _ref = this._channelTypes;
      for (_ in _ref) {
        type = _ref[_];
        type.unsubscribe(subscriberId, callback);
      }
    } else {
      if (numChannels > 1) {
        callback = finishAfter(numChannels, callback);
      }
      for (_i = 0, _len = channels.length; _i < _len; _i++) {
        channel = channels[_i];
        if (!(type = this._channelType(channel))) {
          throw new Error("Channel " + channel + " doesn't match a channel type");
        }
        type.unsubscribe(subscriberId, channel, callback);
      }
    }
    return this;
  },
  hasSubscriptions: function(subscriberId) {
    var type, _, _ref;
    _ref = this._channelTypes;
    for (_ in _ref) {
      type = _ref[_];
      if (type.hasSubscriptions(subscriberId)) {
        return true;
      }
    }
    return false;
  },
  subscribedTo: function(subscriberId, channel) {
    return this._channelType(channel).subscribedTo(subscriberId, channel);
  },
  addChannelInterface: function(channelType, intf) {
    var fn, name, type;
    type = this._channelTypes[channelType];
    for (name in intf) {
      fn = intf[name];
      type[name] = fn;
    }
  },
  _channelType: function(x) {
    var type, _, _ref;
    _ref = this._channelTypes;
    for (_ in _ref) {
      type = _ref[_];
      if (type(x)) {
        return type;
      }
    }
  },
  disconnect: function() {
    return this.emit('disconnect');
  }
};
