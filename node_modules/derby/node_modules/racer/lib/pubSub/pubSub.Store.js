// Generated by CoffeeScript 1.3.1
var PubSub, deserialize, deserializeQuery, fetchPathData, fetchQueryData, finishAfter, hasKeys, lookup, patternMatchingDatum, racer, splitPath, subscribeWithFetch, _ref;

_ref = require('../path'), splitPath = _ref.split, lookup = _ref.lookup;

finishAfter = require('../util/async').finishAfter;

hasKeys = require('../util').hasKeys;

racer = require('../racer');

PubSub = require('./PubSub');

deserializeQuery = require('./Query').deserialize;

deserialize = function(targets) {
  var i, target, _i, _len;
  for (i = _i = 0, _len = targets.length; _i < _len; i = ++_i) {
    target = targets[i];
    if (Array.isArray(target)) {
      targets[i] = deserializeQuery(target);
    }
  }
  return targets;
};

module.exports = {
  type: 'Store',
  events: {
    init: function(store, opts) {
      var clientSockets, liveQueries, nextTxnNum, pubSub, txnClock;
      pubSub = store._pubSub = new PubSub;
      store._liveQueries = liveQueries = {};
      store._clientSockets = clientSockets = {};
      nextTxnNum = {};
      store._txnClock = txnClock = {
        unregister: function(clientId) {
          return delete nextTxnNum[clientId];
        },
        register: function(clientId) {
          return nextTxnNum[clientId] = 1;
        },
        nextTxnNum: function(clientId) {
          if (!(clientId in nextTxnNum)) {
            this.register(clientId);
          }
          return nextTxnNum[clientId]++;
        }
      };
      pubSub.on('noSubscribers', function(path) {
        return delete liveQueries[path];
      });
      return ['addDoc', 'rmDoc'].forEach(function(messageType) {
        return pubSub.on(messageType, function(clientId, data) {
          var num, socket;
          num = txnClock.nextTxnNum(clientId);
          if (!(socket = clientSockets[clientId])) {
            return;
          }
          return socket.emit(messageType, data, num);
        });
      });
    },
    socket: function(store, socket, clientId) {
      store._clientSockets[clientId] = socket;
      socket.on('disconnect', function() {
        delete store._clientSockets[clientId];
        return store._startTxnBuffer(clientId, 3000);
      });
      socket.on('fetch', function(targets, cb) {
        return store.fetch(clientId, deserialize(targets), cb);
      });
      socket.on('addSub', function(targets, cb) {
        return store.subscribeWithFetch(clientId, deserialize(targets), cb);
      });
      socket.on('removeSub', function(targets, cb) {
        return store.unsubscribe(clientId, deserialize(targets), cb);
      });
      if (store._txnBuffer(clientId)) {
        store._cancelTxnBufferExpiry(clientId);
        return store._flushTxnBuffer(clientId, socket);
      } else {
        return socket.emit('resyncWithStore', function(subs, clientVer, clientStartId) {
          return store._onSnapshotRequest(clientVer, clientStartId, clientId, socket, subs, 'shouldSubscribe');
        });
      }
    }
  },
  proto: {
    fetch: function(clientId, targets, callback) {
      var data, finish, target, _i, _len,
        _this = this;
      data = [];
      finish = finishAfter(targets.length, function(err) {
        var out;
        if (err) {
          return callback(err);
        }
        out = {
          data: data
        };
        _this.emit('fetch', out, clientId, targets);
        return callback(null, out);
      });
      for (_i = 0, _len = targets.length; _i < _len; _i++) {
        target = targets[_i];
        if (target.isQuery) {
          fetchQueryData(this, target, function(path, datum, ver) {
            return data.push([path, datum, ver]);
          }, finish);
        } else {
          fetchPathData(this, target, function(path, datum, ver) {
            return data.push([path, datum, ver]);
          }, finish);
        }
      }
    },
    subscribeWithoutFetch: function(clientId, targets, cb) {
      return this._pubSub.subscribe(clientId, targets, cb);
    },
    subscribeWithFetch: subscribeWithFetch = function(clientId, targets, cb) {
      var data, finish;
      data = null;
      finish = finishAfter(2, function(err) {
        return cb(err, data);
      });
      this.subscribeWithoutFetch(clientId, targets, finish);
      return this.fetch(clientId, targets, function(err, _data) {
        data = _data;
        return finish(err);
      });
    },
    subscribe: subscribeWithFetch,
    unsubscribe: function(clientId, targets, cb) {
      return this._pubSub.unsubscribe(clientId, targets, cb);
    },
    publish: function(path, type, data, meta) {
      var message;
      message = {
        type: type,
        params: {
          channel: path,
          data: data
        }
      };
      return this._pubSub.publish(message, meta);
    },
    _onSnapshotRequest: function(ver, clientStartId, clientId, socket, subs, shouldSubscribe) {
      var _this = this;
      return this._checkVersion(ver, clientStartId, function(err) {
        if (err) {
          socket.emit('fatalErr', err);
        }
        subs = deserialize(subs);
        if (shouldSubscribe) {
          _this.subscribeWithoutFetch(clientId, subs);
        }
        return _this._mode.snapshotSince({
          ver: ver,
          clientId: clientId,
          subs: subs
        }, function(err, _arg) {
          var data, len, num, txns;
          data = _arg.data, txns = _arg.txns;
          if (err) {
            socket.emit('fatalErr', err);
          }
          num = _this._txnClock.nextTxnNum(clientId);
          if (data) {
            return socket.emit('snapshotUpdate:replace', data, num);
          } else if (txns) {
            if (len = txns.length) {
              socket.__ver = transaction.getVer(txns[len - 1]);
            }
            return socket.emit('snapshotUpdate:newTxns', txns, num);
          }
        });
      });
    },
    query: function(query, callback) {
      var db, dbQuery, liveQueries;
      db = this._db;
      liveQueries = this._liveQueries;
      dbQuery = new db.Query(query);
      return dbQuery.run(db, function(err, found) {
        var liveQuery;
        if (query.isPaginated && Array.isArray(found) && (liveQuery = liveQueries[query.hash()])) {
          liveQuery._paginatedCache = found;
        }
        return callback(err, found, db.version);
      });
    }
  }
};

fetchPathData = function(store, path, eachDatumCb, onComplete) {
  var remainder, root, _ref1;
  _ref1 = splitPath(path), root = _ref1[0], remainder = _ref1[1];
  return store.get(root, function(err, datum, ver) {
    if (err) {
      return onComplete(err);
    }
    if (remainder == null) {
      eachDatumCb(path, datum, ver);
    } else {
      patternMatchingDatum(root, remainder, datum, function(fullPath, datum) {
        return eachDatumCb(fullPath, datum, ver);
      });
    }
    return onComplete(null);
  });
};

patternMatchingDatum = function(prefix, remainder, subDoc, eachDatumCb) {
  var appendToPrefix, newPrefix, newValue, property, value, _ref1, _results;
  _ref1 = splitPath(remainder), appendToPrefix = _ref1[0], remainder = _ref1[1];
  _results = [];
  for (property in subDoc) {
    value = subDoc[property];
    if (!(value.constructor === Object || Array.isArray(value))) {
      continue;
    }
    newPrefix = prefix + '.' + property + '.' + appendToPrefix;
    newValue = lookup(appendToPrefix, value);
    if (remainder == null) {
      _results.push(eachDatumCb(newPrefix, newValue));
    } else {
      _results.push(patternMatchingDatum(newPrefix, remainder, newValue, eachDatumCb));
    }
  }
  return _results;
};

fetchQueryData = function(store, query, eachDatumCb, finish) {
  return store.query(query, function(err, result, version) {
    var doc, path, _i, _len;
    if (err) {
      return finish(err);
    }
    if (Array.isArray(result)) {
      for (_i = 0, _len = result.length; _i < _len; _i++) {
        doc = result[_i];
        path = query.namespace + '.' + doc.id;
        eachDatumCb(path, doc, version);
      }
    } else if (result) {
      path = query.namespace + '.' + result.id;
      eachDatumCb(path, result, version);
    }
    return finish(null);
  });
};
