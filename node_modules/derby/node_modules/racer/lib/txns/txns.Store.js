// Generated by CoffeeScript 1.3.1
var Promise, transaction;

Promise = require('../util/Promise');

transaction = require('../transaction');

module.exports = {
  type: 'Store',
  events: {
    init: function(store) {
      var clientSockets, localModels, txnClock;
      clientSockets = store._clientSockets;
      localModels = store._localModels;
      txnClock = store._txnClock;
      store._txnBuffers = {};
      return store._pubSub.on('txn', function(clientId, txn) {
        var buffer, model, num, socket, ver;
        if (clientId === transaction.getClientId(txn)) {
          return;
        }
        if (model = localModels[clientId]) {
          return model._onTxn(txn);
        }
        if (socket = clientSockets[clientId]) {
          ver = transaction.getVer(txn);
          if (ver > socket.__ver) {
            socket.__ver = ver;
            num = txnClock.nextTxnNum(clientId);
            return socket.emit('txn', txn, num);
          }
        } else if (buffer = store._txnBuffer(clientId)) {
          return buffer.push(txn);
        }
      });
    },
    socket: function(store, socket, clientId) {
      var txnClock;
      txnClock = store._txnClock;
      socket.__ver = 0;
      socket.on('txn', function(txn, clientStartId) {
        var ver;
        ver = transaction.getVer(txn);
        return store._checkVersion(ver, clientStartId, function(err) {
          if (err) {
            return socket.emit('fatalErr', err);
          }
          return store._commit(txn, function(err) {
            var num, txnId;
            txnId = transaction.getId(txn);
            ver = transaction.getVer(txn);
            if (err && err !== 'duplicate') {
              return socket.emit('txnErr', err, txnId);
            }
            num = txnClock.nextTxnNum(clientId);
            return socket.emit('txnOk', txnId, ver, num);
          });
        });
      });
      return socket.on('fetchCurrSnapshot', function(ver, clientStartId, subs) {
        return store._onSnapshotRequest(ver, clientStartId, clientId, socket, subs);
      });
    }
  },
  proto: {
    _startTxnBuffer: function(clientId, timeoutAfter) {
      var buffer, txnBuffers,
        _this = this;
      if (timeoutAfter == null) {
        timeoutAfter = 3000;
      }
      txnBuffers = this._txnBuffers;
      if (clientId in txnBuffers) {
        console.warn("Already buffering transactions for client " + clientId);
        console.trace();
        return;
      }
      txnBuffers[clientId] = {
        buffer: buffer = [],
        timeout: setTimeout(function() {
          _this.unsubscribe(clientId);
          _this._txnClock.unregister(clientId);
          return delete txnBuffers[clientId];
        }, timeoutAfter)
      };
      return buffer;
    },
    _txnBuffer: function(clientId) {
      var _ref;
      return (_ref = this._txnBuffers[clientId]) != null ? _ref.buffer : void 0;
    },
    _cancelTxnBufferExpiry: function(clientId) {
      return clearTimeout(this._txnBuffers[clientId].timeout);
    },
    _flushTxnBuffer: function(clientId, socket) {
      var txnBuffers, txns;
      txnBuffers = this._txnBuffers;
      txns = txnBuffers[clientId].buffer;
      socket.emit('snapshotUpdate:newTxns', txns);
      return delete txnBuffers[clientId];
    }
  }
};
