// Generated by CoffeeScript 1.3.1
var EventEmitter, Model, Promise, Store, bufferifyMethods, createAdapter, eventRegExp, finishAfter, racer, socketio, subPathToDoc, transaction, _ref, _ref1,
  __slice = [].slice;

EventEmitter = require('events').EventEmitter;

socketio = require('socket.io');

racer = require('./racer');

Promise = require('./util/Promise');

createAdapter = require('./adapters').createAdapter;

transaction = require('./transaction.server');

_ref = require('./path'), eventRegExp = _ref.eventRegExp, subPathToDoc = _ref.subPathToDoc;

_ref1 = require('./util/async'), bufferifyMethods = _ref1.bufferifyMethods, finishAfter = _ref1.finishAfter;

Model = racer["protected"].Model;

Store = module.exports = function(options) {
  var clientId, createMode, db, method, modeOptions, routes, type, _i, _len, _ref2;
  if (options == null) {
    options = {};
  }
  EventEmitter.call(this);
  this._localModels = {};
  modeOptions = options.mode ? Object.create(options.mode) : {
    type: 'lww'
  };
  modeOptions.store = this;
  createMode = require('./modes/' + modeOptions.type);
  this._mode = createMode(modeOptions);
  this._db = db = createAdapter('db', options.db || {
    type: 'Memory'
  });
  this._writeLocks = {};
  this._waitingForUnlock = {};
  this._clientId = clientId = createAdapter('clientId', options.clientId || {
    type: 'Rfc4122_v4'
  });
  this._generateClientId = clientId.generateFn();
  this.mixinEmit('init', this, options);
  this._routes = routes = {};
  _ref2 = ['accessor', 'mutator'];
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    type = _ref2[_i];
    for (method in Store[type]) {
      routes[method] = [];
    }
  }
  db.setupRoutes(this);
};

Store.prototype = {
  __proto__: EventEmitter.prototype,
  _commit: function(txn, cb) {
    return this._mode.commit(txn, cb);
  },
  listen: function(to, namespace) {
    var io, socketUri;
    io = socketio.listen(to);
    io.configure(function() {
      io.set('browser client', false);
      return io.set('transports', racer.get('transports'));
    });
    io.configure('production', function() {
      return io.set('log level', 1);
    });
    socketUri = typeof to === 'number' ? ':' + to : '';
    if (namespace) {
      return this.setSockets(io.of("/" + namespace), "" + socketUri + "/" + namespace);
    } else {
      return this.setSockets(io.sockets, socketUri);
    }
  },
  setSockets: function(sockets, _ioUri) {
    var _this = this;
    this.sockets = sockets;
    this._ioUri = _ioUri != null ? _ioUri : '';
    return sockets.on('connection', function(socket) {
      var clientId;
      clientId = socket.handshake.query.clientId;
      if (!clientId) {
        return socket.emit('fatalErr', 'missing clientId');
      }
      return _this.mixinEmit('socket', _this, socket, clientId);
    });
  },
  flushMode: function(cb) {
    return this._mode.flush(cb);
  },
  flushDb: function(callback) {
    return this._db.flush(callback);
  },
  flush: function(callback) {
    var finish;
    finish = finishAfter(2, callback);
    this.flushMode(finish);
    return this.flushDb(finish);
  },
  disconnect: function() {
    var _base, _base1, _base2, _base3;
    if (typeof (_base = this._mode).disconnect === "function") {
      _base.disconnect();
    }
    if (typeof (_base1 = this._pubSub).disconnect === "function") {
      _base1.disconnect();
    }
    if (typeof (_base2 = this._db).disconnect === "function") {
      _base2.disconnect();
    }
    return typeof (_base3 = this._clientId).disconnect === "function" ? _base3.disconnect() : void 0;
  },
  _checkVersion: function(ver, clientStartId, cb) {
    if (this._mode.checkStartMarker) {
      return this._mode.checkStartMarker(clientStartId, cb);
    }
    return cb(null);
  },
  _nextTxnId: function(callback) {
    var _this = this;
    this._txnCount = 0;
    return this._generateClientId(function(err, clientId) {
      if (err) {
        return callback(err);
      }
      _this._clientId = clientId;
      _this._nextTxnId = function(callback) {
        return callback(null, '#' + this._clientId + '.' + this._txnCount++);
      };
      return _this._nextTxnId(callback);
    });
  },
  _finishCommit: function(txn, ver, callback) {
    var dbArgs, method,
      _this = this;
    transaction.setVer(txn, ver);
    dbArgs = transaction.copyArgs(txn);
    method = transaction.getMethod(txn);
    dbArgs.push(ver);
    return this._sendToDb(method, dbArgs, function(err, origDoc) {
      _this.publish(transaction.getPath(txn), 'txn', txn, {
        origDoc: origDoc
      });
      if (callback) {
        return callback(err, txn);
      }
    });
  },
  createModel: function() {
    var clientIdPromise, localModels, model, startIdPromise;
    model = new Model;
    model.store = this;
    model._ioUri = this._ioUri;
    if (this._mode.startId) {
      model._startIdPromise = startIdPromise = new Promise;
      model._bundlePromises.push(startIdPromise);
      this._mode.startId(function(err, startId) {
        model._startId = startId;
        return startIdPromise.resolve(err, startId);
      });
    }
    localModels = this._localModels;
    model._clientIdPromise = clientIdPromise = new Promise;
    model._bundlePromises.push(clientIdPromise);
    this._generateClientId(function(err, clientId) {
      model._clientId = clientId;
      localModels[clientId] = model;
      return clientIdPromise.resolve(err, clientId);
    });
    return model;
  },
  _unregisterLocalModel: function(clientId) {
    var localModels;
    localModels = this._localModels;
    delete localModels[clientId].store;
    return delete localModels[clientId];
  },
  route: function(method, path, priority, fn) {
    var currPriority, handler, i, re, routes, _i, _len;
    if (typeof priority === 'function') {
      fn = priority;
      priority = 0;
    } else {
      priority || (priority = 0);
    }
    re = eventRegExp(path);
    handler = [re, fn, priority];
    routes = this._routes[method];
    for (i = _i = 0, _len = routes.length; _i < _len; i = ++_i) {
      currPriority = routes[i][2];
      if (priority <= currPriority) {
        continue;
      }
      routes.splice(i, 0, handler);
      return this;
    }
    routes.push(handler);
    return this;
  },
  _sendToDb: function(method, args, done) {
    var i, lockingDone, next, path, pathToDoc, rest, routes, _base,
      _this = this;
    path = args[0], rest = 2 <= args.length ? __slice.call(args, 1) : [];
    if (method !== 'get') {
      pathToDoc = subPathToDoc(path);
      if (pathToDoc in this._writeLocks) {
        return ((_base = this._waitingForUnlock)[pathToDoc] || (_base[pathToDoc] = [])).push([method, args, done]);
      }
      this._writeLocks[pathToDoc] = true;
      done || (done = function(err) {
        if (err) {
          throw err;
        }
      });
      lockingDone = function() {
        var buffer, __done, _ref2;
        delete _this._writeLocks[pathToDoc];
        if (buffer = _this._waitingForUnlock[pathToDoc]) {
          _ref2 = buffer.shift(), method = _ref2[0], args = _ref2[1], __done = _ref2[2];
          if (!buffer.length) {
            delete _this._waitingForUnlock[pathToDoc];
          }
          _this._sendToDb(method, args, __done);
        }
        return done.apply(null, arguments);
      };
    } else {
      lockingDone = done;
    }
    routes = this._routes[method];
    i = 0;
    return (next = function() {
      var captures, fn, handler, match, re;
      if (!(handler = routes[i++])) {
        throw new Error("No persistence handler for " + method + "(" + (args.join(', ')) + ")");
      }
      re = handler[0], fn = handler[1];
      if (!(path === '' || (match = path.match(re)))) {
        return next();
      }
      captures = path === '' ? [''] : match.length > 1 ? match.slice(1) : [match[0]];
      return fn.apply(null, captures.concat(rest, [lockingDone, next]));
    })();
  }
};

Store.MODES = ['lww', 'stm'];

bufferifyMethods(Store, ['_sendToDb'], {
  await: function(done) {
    var db;
    db = this._db;
    if (db.version !== void 0) {
      return done();
    }
    return this._mode.version(function(err, ver) {
      if (err) {
        throw err;
      }
      db.version = ver;
      return done();
    });
  }
});
